from typing import Dict, Any, List
from .discussion_agents import DiscussionAnalysisAgent, DiscussionStrategyAgent, DiscussionGenerationAgent
from .grouping_agent import GroupingAgent
from .summarization_agent import SummarizationAgent

class AgentCoordinator:
    """
    Coordinates the multi-agent pipeline for discussion generation, grouping, and summarization.
    """
    def __init__(self, client, model: str):
        self.client = client
        self.model = model
        
        # Instantiate agents
        self.analysis_agent = DiscussionAnalysisAgent(client, model)
        self.strategy_agent = DiscussionStrategyAgent(client, model)
        self.generation_agent = DiscussionGenerationAgent(client, model)
        self.grouping_agent = GroupingAgent(client, model)
        self.summarization_agent = SummarizationAgent(client, model)

    def generate_discussion_questions(
        self,
        activity_metadata: Dict,
        student_responses: List[Dict],
        rubric_criteria: List[Dict],
        num_questions: int = 4
    ) -> Dict:
        """
        Runs the Analysis -> Strategy -> Generation pipeline.
        """
        total_tokens = 0
        
        # Step 1: Analysis
        analysis_context = {
            "activity_metadata": activity_metadata,
            "student_responses": student_responses
        }
        analysis_result = self.analysis_agent.run(analysis_context)
        knowledge_state = analysis_result["knowledge_state"]
        total_tokens += analysis_result.get("tokens_used", 0)
        
        # Step 2: Strategy
        strategy_context = {
            "knowledge_state": knowledge_state,
            "num_questions": num_questions,
            "rubric_criteria": rubric_criteria
        }
        strategy_result = self.strategy_agent.run(strategy_context)
        strategy = strategy_result["strategy"]
        total_tokens += strategy_result.get("tokens_used", 0)
        
        # Step 3: Generation
        generation_context = {
            "strategy": strategy,
            "activity_metadata": activity_metadata,
            "knowledge_state": knowledge_state
        }
        generation_result = self.generation_agent.run(generation_context)
        final_output = generation_result["generated_questions"]
        total_tokens += generation_result.get("tokens_used", 0)
        
        # Combine results
        return {
            "summary": strategy.get("summary_of_strategy", "Generated by Multi-Agent System"),
            "questions": final_output.get("questions", []),
            "model": self.model,
            "tokens_used": total_tokens,
            "pipeline_details": {
                "knowledge_state": knowledge_state,
                "strategy": strategy
            }
        }

    def generate_student_groups(
        self,
        student_data: List[Dict],
        activity_context: str,
        strategy: str = "heterogeneous",
        group_size: int = 4
    ) -> Dict:
        """
        Uses the GroupingAgent to cluster students.
        """
        context = {
            "student_data": student_data,
            "activity_context": activity_context,
            "strategy": strategy,
            "group_size": group_size
        }
        
        result = self.grouping_agent.run(context)
        
        return {
            "groups": result.get("groups", []),
            "tokens_used": result.get("tokens_used", 0),
            "model": self.model
        }
    
    def summarize_discussion(
        self,
        messages: List[Dict],
        discussion_topic: str = "",
        discussion_questions: List[str] = []
    ) -> Dict:
        """
        Uses the SummarizationAgent to summarize discussion.
        """
        context = {
            "messages": messages,
            "discussion_topic": discussion_topic,
            "discussion_questions": discussion_questions
        }
        
        result = self.summarization_agent.run(context)
        
        return {
            "summary_data": result.get("summary_data", {}),
            "tokens_used": result.get("tokens_used", 0),
            "model": self.model
        }
